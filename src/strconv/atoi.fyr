func parseInt<T>(s string, base Base | "auto") (T, bool) {
	if (len(s) == 0) {
		return 0, false
	}
    
	var offset = 0

    var b T = 10
    if (base == "auto") {
		// Look for octal, hex prefix.
        if (s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X')) {
			if (len(s) < 3) {
				return 0, false
			}
			b = 16
			offset = 2
        } else if (s[0] == '0') {
			b = 8
			offset = 1
		}
    } else if (base == "2") {
        b = 2
    } else if (base == "8") {
        b = 8
    } else if (base == "16") {
        b = 16
    }

	// cutoff is the smallest number such that cutoff*base > max(T).
    let cutoff T = max<T>/b + 1

	var n T = 0
    let l = len(s)
	for (; offset < l; offset++) {
        let c = s[offset]
		var d byte
		if ('0' <= c && c <= '9') {
			d = c - '0'
        } else if ('a' <= c && c <= 'z') {
			d = c - 'a' + 10
		} else if ('A' <= c && c <= 'Z') {
			d = c - 'A' + 10
		} else {
			return 0, false
		}

		if (d >= <byte>b) {
			return 0, false
		}

		if (n >= cutoff) {
			// n*base overflows
			return max<T>, false
		}
		n *= b

		let n1 = n + <T>d
		if (n1 < n) {
			// n+v overflows
			return max<T>, false
		}
		n = n1
	}

	return n, true
}

func atoi<T>(s string) (T, bool) {
    return parseInt<T>(s, "auto")
}