type S struct {
    value int
}

func S.f() {
    ptr.value = 84
    ptr = null
    if (ptr == null) {
        return
    }
    this.value = 42
}

func S.f2(r const ~S) {
}

var ptr *S = {}
let ptr2 *S = {}

func factory() *S {
    return {}
}

func donateRef() ~S {
    return null
}

func sliceme(s ~[]int) {
}

type H struct {
    value int
    slice []int
}

export func main() int {
    // ptr needs locking
    ptr.f()
    ptr2.f()
    var lptr *S = {}
    let lptr2 *S = {}
    // ptr needs incref
    // lptr needs notnull
    lptr.f2(ptr)
    // lptr needs notnull
    lptr.f2(ptr2)
    // lptr needs notnull
    lptr.f2(lptr)
    lptr2.f2(lptr)
    // Needs free after f()
    factory().f()
    // Needs free after f()
    lptr2.f2({})
    // Needs decref after f()
    let lptr3 *S = {}
    lptr3.f2(donateRef())
    let lptr4 *S = factory()
    lptr4.f()
    let hptr *H = {}
    sliceme(hptr.slice)
    let s []int = [1, 2]
    return 0
}