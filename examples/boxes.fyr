type Point struct {
    x int
    y int
}

type Widget struct {
    sibling *Widget
}

type PointTuple struct {
    a *Point
    b *Point
}

type PointRef struct {
    p &Point
    p2 &Point
    p3 *Point
    r &PointRef
    u ^Point
    pos Point
}

type Link struct {
    next *Link
    value *Point
    parallel ^Link
    pos Point
}

func main(param *Point, param2 *Point, param3 *Point, param4 *Point, param5 *Point, param6 *Point, pl1 *Link) {
    var a int = 1;
    var b int = a;
    var ptr &int = &a;

//    var p *Point = {x: 1, y: 2}
    a = param.x
    var p *Point = param
    // Must err, because p is tainted by param which is extern
//    var fuck ^Point = p

    a = p.x
    p.x = 5
    var r &Point = p
    a = r.x    
    var ptr2 &*Point = &p
    var p2 *Point = p
    // Must err because p is not initialized here
//    a = p.x
    a = r.x
    a = p2.x
    var r2 &Point = p2
    a = r2.x
    // Must err because p is not initialized here
//    p.x = 5
    // Must err because ptr2 points to a location that is not initialized
//    var ptr4 &*Point = ptr2
    p = {x: 1, y: 2}
    a = p.x
    // Must not err because ptr2 points to a location that is now initialized again
    var ptr3 &*Point = ptr2

    var w2 *Widget = {sibling: null}
    var w1 *Widget = {sibling: w2}
    // Must err, because w2 is not accessible
//    w2 == w1

    // Must err, because the take operator is missing
//    var w4 *Widget = w1.sibling;
    var w3 *Widget = take(w1.sibling)

    var up1 ^Point = {x: 1, y: 2}
    // Must err, because param2 is extern
//    var up2 ^Point = param2
    // Must err, because p2 is extern because of param 
//    var up3 ^Point = p2
    // Works, because p was reassigned a pointer to something that is not extern
    var up4 ^Point = p

    var r4 &Point = up4

    var pt *PointTuple = {a: up1, b: up4}
    var upt ^PointTuple = pt

    var pr *PointRef = {p: r4}
    var upr ^PointRef = pr

    // Works. Forces pr2 and param2 into the same box
    var pr2 *PointRef = {p: param2}
//    var pr2 *PointRef = {}
//    pr2.p = param2
    // Must err, because pr2 is joind with param p2 and can therefore not be joined with param3.
//    pr2.p2 = param3
    // Must err, because param2 and p2 can not be joined
//    var prx *PointRef = {p: param2, p: param3}

    var u5 ^Point = take(pr2.u)
    // Must err, because pr2 is tainted by param2 which is extern
//    var u6 ^Point = take(pr2.p3)
    // Must err, because pr2 is tainted by param2 which is extern
//    var u7 ^PointRef = pr2

    var link1 *Link = {}
    var link2 *Link = {value: param4}
    link1.next = link2
    // Must err, because link2 is no longer available
//    link2
    // Must err, because link2 is tainted by param which is extern
//    var extlink ^Link = link1
    // Must err, because link1 is tainted by param which is extern
//    var extlink0 ^Link = link1.next
    // Must err, because link1 is tainted by param which is extern
//    var extlink1 ^Link = take(link1.next)
    // Must err, because link1 is tainted by param which is extern
//    var extlink1 ^Link = take(link1.next.next)
    // Must err, because link2 is tainted by param which is extern
//    var extlink2 ^Link = link1
    var link3 *Link = take(link1.next)
    // Must err, because link2 is tainted by param which is extern
//    var extlink3 ^Link = link3
    var link4 *Link = {value: param5}
    // Must err, because link4 cannot join param5 and param6
//    link4.next.next.next = {value: param6}
    link4.parallel = {}
    // Must err, because pl1 cannot be isolated
//    link4.parallel = pl1
    //!! Must err, because param6 cannot be isolated    
    link4.parallel.next = {value: param6}
    var link6 *Link = {}
    var extlink3 ^Link = take(link6.next)
    //!! Must err, because link6 is no longer available
    link6
    var r1 &Link = link4.next
    // Must err, because accessing a pointer inside of an isolate would violate the isolation
//    var r3 &Link = link4.parallel.next
    // Must err, because link5 could still be pointed to by objects in the 'parallel' isolation
//    var link5 *Link = take(link4.parallel.next)
    // Works, because the result of the expression is being copied and therefore the isolation is ok after the expression evaluated.
    var p5 Point = link4.parallel.pos
    // Must err, because taking the address of a value inside of an isolate would violate the isolation
//    var r5 &Point = &link4.parallel.pos
    var pr4 ^PointRef = {}
    var pr3 ^PointRef = {}
    //!! Must err, because it violates the isolation between pr3 and pr4
    pr3.r = pr4
    // Must err, because accessing a pointer inside an isolate (pr4) violates this isolation
//    pr4.r
    // Works, because this expression returns a value and not a pointer
    pr4.pos
}

func merge(w1 *Widget, w2 *Widget) {
    // Must err, because w1 and w2 belong to different boxes that cannot be joined
//    w1.sibling = w2
    // Must err, because w1 and w2 belong to different boxes
//    w1 = w2
}

func merge2(w1 *:Widget, w2 *:Widget) {
    // Must err, because w1 and w2 belong to different boxes that cannot be joined
//    w1.sibling = w2
    // Must err, because w1 and w2 belong to different boxes
//    w1 = w2
}

func merge3(w1 *a:Widget, w2 *Widget) (r1 *a:Widget, r2 *Widget) {
    // Must err, because w1 and w2 belong to different boxes that cannot be joined
//    w1.sibling = w2
    // Must err, because w1 and w2 belong to different boxes that cannot be joined
//    w1 = w2
    // Works, because {} can be joined with the box of w1
    w1 = {}
    r1 = w1
    // Must err, because w2 and r2 belong to different boxes
//    r2 = w2
    return
}

func merge4(w1 *a:Widget, w2 *b:Widget) (r1 *a:Widget, r2 *b:Widget) {
    // Must err, because of different boxes
//    return w2, w1
    return w1, w2
}

func test5(w *a:Widget) *a:Widget {
    return w
}

type SliceStruct struct {
    s []int
    p *Point
}

func sliceTest(p []int, p1 *Point, p2 *Point, p3 *Point, p4 *Point, ps1 []*Point, ps2 []&Point) {
    var s1 []int = [1, 2, 3]
    var s2 ^[]int = [4, 5, 6, 7]
    var s3 ^[]int = s1
    // Must err, because s1 is no longer available
//    var s4 []int = s1
    // Must err, because p is external
//    var s5 ^[]int = p
    var s6 []int = p
    p = s6
    p = s3
    var ss1 *SliceStruct = {s: [1, 2, 3]}
    var ss2 *SliceStruct = {}
    var s7 []int = [1, 2, 3]
    ss2.s = s7
    ss2.p = {x: 1, y: 2}
    ss2.s = [1, 2, 3]
    ss2.s = p

    var s8 []*Point = [{x:1, y: 2}, {x:3, y:4}]
    var a1 [2]*Point = [{x:1, y: 2}, {x:3, y:4}]
    var s9 []*Point = [p1, p2]
    // Must err, because s9 cannot be joined because of p1 and p2
//    var s10 ^[]*Point = s9

    var s11 []*Point = []
    s11[0] = p3
    s11[1] = p4
    // Must err, because p3 and p4 cannot be joined into one box
//    ps1 = s11
    ps1 = s8
    
    var s12 []&Point = []
    var lp Point = {}
    s12[0] = &lp
    // Must err, because s12 holds a reference to a local variable
//    ps2 = s12

    var s13 []&Point
    // Must err, because s13 is not available here
//    s13[0] = &lp
}

func boxesTest(arr []*a:Point, s *a:SliceStruct) {
    s.p = take(arr[0])
    var arr2 []*Point = arr
    s.p = take(arr2[0])
    arr2[0] = take(s.p)
    s.p = {}
}

func links(l1 *Link, l2 *Link, l3 *a:Link, l4 *a:Link) {
    // Must err, because both links are from different boxes
//    l1.next = l2
    l3.next = l4
}

func points(p1 const &Point, p2 const &Point) {
    var a1 Point = {}
    var a2 *Point = {}
    // Must work, because argument belong to different groups by default
//!!    points(&a1, a2)
}

func test(p1 *:Point, p2 *:Point) {
    var s SliceStruct = {}
    s.p = {}
    s.p = p1
    // Must err, because s is joined with p1 already and cannot be joined with p2
//    s.p = p2
    s = {}
    // Must err, because s is joined with p1 already and cannot be joined with p2. Reassigning makes no difference here.
//    s.p = p2
    var s2 SliceStruct = {}
    s2.p = p2
}

func test2(r1 &Point, r2&a:Point) &a:Point {
    // Must err, r1 and a cannot be joined    
//    return r1
    return r2
}

func test3(r1 &Point) &Point {
    // Must err, r1 and anonymous box cannot be joined    
//    return r1
    var p Point = {}
    // Must work, however when the stack is cleared, the reference is null.
    // Thus, the returned value is always null.
    // Should be flagged with a warning, since it is most likely a programming error.
    return &p
}