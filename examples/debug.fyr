type Point struct {
    x int
    y int
}

type SliceStruct struct {
    p *Point
}

type Link struct {
    next *Link
    value *Point
    parallel ^Link
    pos Point
    sibling &Link
}

type PointRef struct {
    ptr *PointRef
    ref &PointRef
    unique ^PointRef
    pos Point
}

func funcTest(param1 *Link) *Link {
    var funky *Link = {}
    var r = doIt(funky, param1)
    return r
}

func funcTest2() {
    var l *Link = {}
    // Must err
//    doIt(l, l)
    doIt(l, {})
}

func doIt(l1 *Link, l2 *Link) ^Link {
    // Must err
//    return l1
    var v1 *Link
    var v2 ^Link
    v1, v2 = tupleMe()
    // Must err
//    return v1
    return v2
//    var v3 ^Link = doIt(null, null)
//    return v3
}

func tupleMe() (*Link, ^Link) {
    return {}, {}
}

func testUnique(l ^Link) {

}

func testUnique2() {
    var p *Link = {}
    var p2 *Link = {}
    p.next = p2
    testUnique(p)
    // Must err
//    p
    // Must err
//    p2
}

func ifTest(`a l1 *Link, `a l2 *Link, `b l3 *Link) {
    var v1 *Link
    if (true) {
        v1 = l1
    } else {
        v1 = l3
    }
    // Must err
//    l2.next = v1
}

func ifTest2(`a xl1 *Link, `a xl2 *Link, `b xl3 *Link) {
    var v2 *Link = {}
    if (true) {
        v2.next = xl1
    } else {
        v2.next = xl3
    }
    // Must err
//    xl2.next = v2
}

func forTest(`a l1 *Link, `a l1b *Link, `b l2 *Link, `c l3 *Link) {
    var v3 *Link = l1b
    for(var a = 0; a < 10; a++) {
        v3.next = l1
        if (a > 4) {
            break
        }
        l1 = {}
        var v4 *Link
        if (a > 4) {
            v4 = {}
        } else {
            v4 = {}
        }
        v4.next = l3
        l3 = null
    }
    // Must err, becaise l1 could have been assigned and then break left the loop
//    l1
}

func refTest(l &Link) {
    var l2 Link = {}
    refTest(&l2)
    // Must err, because &l2 is a local reference
//    refTest2(&l2)
}

func refTest2(`a l3 &Link) {    
}