type Point struct {
    x int
    y int
}

type SliceStruct struct {
    p *Point
}

type Link struct {
    next *Link
    value *Point
    parallel ^Link
    pos Point
    sibling ~Link
}

type PointRef struct {
    ptr *PointRef
    ref ~PointRef
    unique ^PointRef
    pos Point
    tuple (*PointRef, *PointRef)
}

var link1 *Link
var link2 *Link
// Must err, because link3 is in a different group
// var link3 ^Link = take(link1.next)
var link3 ^Link = {}

func test(param1 *PointRef, `b param2 *PointRef, param3 ~PointRef, param4 *PointRef, `c param5 *PointRef) *PointRef {
    var pr4 ^PointRef = {}
    var pr3 ^PointRef = {}
    pr3.ref = pr4
    var pr5 ~PointRef = pr3
    var pr6 ^PointRef = pr3
    pr5
    pr6
    // Must err, because pr3 has been assigned to pr6
//    pr3
    // Must work, because pr4 and pr3 are now entagled
    pr4
    // Works, because pr4 was only assigne to a ~ptr and pos is a value
    var p Point = pr4.pos
    // Works, because pr7 is now bound to pr4
    var pr7 *PointRef = take(pr4.ptr)
    // Must err, because we access the inside of an isolate
//    var pr8 *PointRef = take(pr4.unique.ptr)
    // Works, because we access an isolate inside an isolate
    var pr9 *PointRef = take(pr4.unique.unique)
    var pr10 ^PointRef = {}
    var ref10 ~PointRef = pr10
    pr4.unique = pr10
    // Must err, because pr10 variable is no longer available
//    pr10
    // Must err, because the group of pr10 is no longer available
//    ref10
    pr4.unique = take(pr4.unique.unique)
    // Must err, because we access the inside of an isolate
//    pr4.unique = take(pr4.unique.ptr)
    pr4.unique = take(pr4.ptr)
    // Must err, because pr3, pr4 and pr6 are entangled
//    pr6
    // Must err, because pr4 and everything it points to became unavailable above
//    pr4
    // Must err, because param1 is bound
//    pr4 = param1
    var pr11 ^PointRef = {}
    // Works, because pr11 is now bound to param1
    pr11.ptr = param1
    // Must err, because pr11 is bound to param1, and cannot be bound to param2
//    pr11.ptr = param2
    // Must err, because param3 is passed as in its own bound group
//    param3.ptr = param4
    // Must err, because pr11 is not isolated
//    param3.unique = pr11
    var pr15 ^PointRef = {}
    param5.ptr = pr15

    link1 = {}
    link2 = {}
    link1.sibling = link2
    link2.sibling = link1
    // Must err, because link3 is unique and therefore in a different group
//    link3.sibling = link1

    var pr12 ^PointRef = {}
    // Must err, because we must not take pointers out of isolates
//    var pr16 = take(pr12.unique.ptr)
    var pr13 = take(pr12.unique.unique)
    // Must work, because pr13 is free
    pr13.ptr = param4
    var pr14 *PointRef = {}
    // Must err, because isolates may only be taken out of isolates, but not referenced
//    var pr17 ~PointRef = pr14.unique.unique
    // Must err, because param2 belongs to the wrong group
//    return param2
    // Must err, because param1 is not available
//   return param1
    return {}
}

func tupleTest(param1 *Link, `b param2 *Link) {
    var x *Link, y *Link = (param2, param1)
    // Must err, because x and y belong to different groups that cannot be joined
//    x.sibling = y
    var tuple (*Link, *Link) = ({}, {})
    var a, b = tuple
    // Must err, because tuple is no longer available
//    tuple
    var pr *PointRef = {}
    // Must err, because take is missing
//    var tuple3 = pr.tuple
    var tuple2 = take(pr.tuple)
}

func doIt() {
    var l *Link = {}
    l.setNext({})
    var r ~Link = l
    r.setNext({})
}

func Link.setNext(n *Link) {
    this.next = n
}

func sliceTest(s ^[]int) ^[]int {
    var sub = s[1:3]
    // Must err, because sub is a reference slice only
//    return sub
    var sub2 = take(s)[1:3]
    // Must err, because s is no longer available
//    s
    return sub2
}